clear;clc
%%   steering vector obtained from source position
load('avec_a_20nodes');%amplitude
load('avec_tao_20nodes');%phase
%% inputs
M = 20; % node number
Nnode = 7;   % the number of activated nodes

SNR_min = 12.5; % dB
SNR_max = 26; % dB
RT60 = 300; % ms

N = 1024;  % frame length
Ns = N/2;  % overlap
K = N;     % Num of frequency bins
Len = 600; % frame number
%% add reverberation and noises
filename = 'rt300.mat'; % RIR generated by IMAGE Source method when RT60 = 300ms
rir = load(filename);
RIR = rir.RIR_cell;

avec_dis = 1 ./ avec_a_20nodes;
dis_tmp = (SNR_max - SNR_min)/(max(avec_dis)-min(avec_dis));
% % RIR filter
[x_ori, F_msc] = audioread('speech_female.wav');
for i = 1:M
    x(:,i) = filter(RIR{i,1}(:,1),1,x_ori);
    SNR(i) = SNR_max - ( avec_dis(i)-min(avec_dis) ) * dis_tmp;
    x(:,i) = awgn(x(:,i),SNR(i),'measured');
end
x = 1.5e4*x;
%% VAD threshold
for i = 1:M
    thh(i) = Vad_thr(x(:,i)); % threshold
end
%%  Rvv computation
% rough time synchronization
len_rts = 2048;
x_total =  x(1:len_rts,:);
for z = 1:M
    tao(z) = gccphat(x_total(1:len_rts,z), x_total(1:len_rts,1));
end
[a_t,b_t] = min(tao);
tao = (tao - a_t);

xr = zeros(Len*Ns+N,M);
for z = 1:M
    
    xr_tmp=  x(:,z);  xr_tmp(1:tao(z)) = []; 
    xr(1:Len*Ns+N,z) = xr_tmp(1:Len*Ns+N,1);
end

% Rvv = zeros(M,M,K,Len); % cross power spectrum
flag = 0;
frame_idx = zeros(Len,1);
for i = 1:Len
    
    for j = 1:M
        x_tmp = xr((i-1)*Ns+(1:N),j);
        P_tmp = 1/N * sum(x_tmp.^2);
        if P_tmp >= thh(j)
            break;
        end
    end    
    
    if j == M  % all nodes capture noise frame  
        flag = flag + 1;
        frame_idx(i) = 1;
        
        for j = 1:M
            X(:,j) = fft(xr((i-1)*Ns+(1:N),j),K);  % FFT
        end
                  
        for k = 1:K
             corrvar = X(k,:).' * conj(X(k,:));
            Rvv(1:M,1:M,k,flag) =corrvar/ trace(corrvar);            
        end                              
    end      
end
glo_Rvv = mean(Rvv,4);

%% Weight matrix and Adjacency matrix construction
% W is the weight matrix in the subsequent distributed consensus stages
  W =  [17/20 1/20 0.00 0.00 1/20 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;%1
        1/20 18/20 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 1/20 18/20 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 1/20 18/20 0.00 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        1/20 0.00 0.00 0.00 17/20 1/20 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        1/20 0.00 0.00 0.00 1/20 17/20 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;%6
        0.00 0.00 0.00 0.00 0.00 1/20 18/20 0.00 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 1/20 0.00 0.00 0.00 19/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 1/20 0.00 0.00 0.00 17/20 1/20 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 17/20 1/20 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 1/20 16/20 1/20 0.00 0.00 1/20 0.00 0.00 0.00 0.00 0.00;%11
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 17/20 0.00 0.00 1/20 1/20 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 0.00 17/20 1/20 0.00 0.00 1/20 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 1/20 17/20 1/20 0.00 0.00 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 1/20 0.00 1/20 15/20 0.00 0.00 0.00 1/20 1/20;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 0.00 18/20 0.00 0.00 0.00 1/20;%16
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 0.00 19/20 0.00 0.00 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 19/20 1/20 0.00;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 0.00 0.00 1/20 17/20 1/20;
        0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 1/20 1/20 0.00 0.00 1/20 17/20;
  ]; 
% W0 is the Adjacency matrix
W0 = ceil(W);
W0 = W0 - diag(diag(W0));   % Adjacency matrix

%%  SNR estimation
tic;
SNR = zeros(M,1);
for i =1:M
    
    for k = 1:K/2+1   
        dvec = avec_a_20nodes(i)  * exp(-sqrt(-1)*2*pi*(k-1)/K*F_msc*avec_tao_20nodes(i));
        SNR(i,1) = SNR(i,1) + 1/(K/2+1)*abs(conj( dvec)*dvec)/abs(glo_Rvv(i,i,k));
    end
end

% f is the cost function
f = -100*SNR'; 
f = f - mean(f); % centering
%%  binary programming, the output is slc which contains the selected nodes
if Nnode <=3
    z = D_SD(-f', W0, Nnode, W);
    count0 = 0;
    while (min(W0*z-z)<0 )
        f = f + ones(1,M);
        z = D_SD(-f', W0, Nnode, W);
        
        count0 =count0 + 1;
    end
    
else
    z = D_SD(-f', W0, 3, W);
    
    count0 = 0;
    while (  min(W0*z-z) < 0 )
        f = f + ones(1,M);
        z = D_SD(-f', W0, 3, W);
        
        count0 =count0 + 1;
    end
end
nodes = 1:M;
slc = nodes(z==1); 
nodes(z==1) = [];


%if Nnode > 3
if Nnode >3
    Nr = Nnode - 3;
    Wr = W0;
    z0= z;
        
    for i = 2: floor(Nr/2)+1
        % new W matrix construction
        psi = diag(ones(M-(i-2)*2,1)-z0); psi(all(psi==0,2),:) = [];  Wtmp = psi*W0*psi'; 
        ind = find(z0==1); sel = sum(W0(ind,:),1);  sel(ind) = [];          
        sel = sign(sel); %%%%%%%%%%%%%%%%
        Wr = [Wtmp sel'; sel 0];
        
        Ws = Wr / size(Wr,2); 
        dtmp = Ws*ones(size(Wr,2),1); 
        Ws = Ws + ( eye(size(Wr,2)) - diag(dtmp) ); % weight matrix for seleceted nodes
        % new SNR vector construction
        SNR_sn =  sum(SNR(ind,:));  SNR(ind,:) = []; SNR = [SNR; SNR_sn];     
        f = -100*SNR'; f = f - mean(f); % 中心化
        z = D_SD(-f', Wr, 3, Ws);
        
        count0 = 0;
        while ( min(Wr*z-z)<0 )
            f = f + ones(1,size(f,2));
            z = D_SD(-f', Wr, 3, Ws);
            
            count0 =count0 + 1;
         end

        W0 = Wr;
        z0 = z;
        %
        slc(1,2*i:2*i+1) =  nodes(z(1:length(z)-1)==1); 
        
        nodes(z(1:length(z)-1)==1) = [];
        
    end
    
    if mod(Nr,2) == 1
         % new W matrix construction
          Nrr = floor(Nr/2);
          psi = diag(ones(M-Nrr*2,1)-z0); psi(all(psi==0,2),:) = [];   Wtmp = psi*W0*psi';
          ind = find(z0==1);  sel = sum(W0(ind,:),1);  sel(ind) = []; sel= sign(sel);
          Wrr= [Wtmp sel'; sel 0]; 
          
        Ws = Wrr / size(Wrr,2); 
        dtmp = Ws*ones(size(Wrr,2),1); 
        Ws = Ws + ( eye(size(Wrr,2)) - diag(dtmp) ); % weight matrix for seleceted nodes
        % new SNR vector construction
        SNR_sn =  sum(SNR(ind,:));  SNR(ind,:) = []; SNR = [SNR; SNR_sn];     
        f = -100*SNR'; f = f - mean(f); % 中心化
        zr = D_SD(-f', Wrr, 2, Ws);   
        
        count0 = 0;
        while (min(Wrr*zr-zr)<0 )
            f = f + ones(1,size(f,2));
            zr = D_SD(-f', Wrr, 2, Ws);
            
            count0 =count0 + 1;
         end
        %
        slc(1,2*(Nrr+1)+2) = nodes(zr(1:length(zr)-1)==1); 
        nodes(zr(1:length(zr)-1)==1) = [];
    end
    
end
toc;
%%  Speech enhancement using selected subnetwork
% Note that the proposed sensor selection method is completely independent of the follow-up speech enhancement approaches
% Thus, it possesses a good versatility and can be adopted for any centralized or distributed speech enhancement approaches,
% Here, a Distribed Sum-and-Delay beamformer proposed by Zeng et al is employed:
%Y. Zeng and R. C. Hendriks, “Distributed delay and sum beamformer for speech enhancement in wireless sensor networks via randomized gossip,” 
%in IEEE Int. Conf. Acoust., Speech, Signal Process., Kyoto, Japan, Mar. 2012, pp. 4037C4040.

%D-DS beamformer
% window
win  = hamming(K);
win = win/sqrt(sum(win(1:Ns:K).^2));

zs = zeros(M,1);  zs(slc) = 1;
W0 = ceil(W); W0 = W0 - diag(diag(W0)); 
psi = diag(zs); psi(all(psi==0,2),:) = [];  Ws = psi*W0*psi'; 
Ws = Ws / Nnode;   Wtmp = Ws*ones(Nnode,1); Ws = Ws + ( eye(Nnode) - diag(Wtmp) ); % weight matrix for seleceted nodes

%
glo_Rvv_s = glo_Rvv(slc,slc,:);
avec_a_20nodes_s = avec_a_20nodes(slc);
avec_tao_20nodes_s = avec_tao_20nodes(slc);
xs = x(:,slc);


for j = 1:Nnode    
    X_win(:,:,j) = fft(enframe(xs(:,j),win,Ns)');   
end


alpha = 0.2;
Wght = zeros(Nnode,K);
for i = 1:Len
   
    if(frame_idx(i)==1)% in noise frames, Rvv is updated
        %fft
        for j = 1:Nnode
            XR(:,j) = fft(xs((i-1)*Ns+(1:N),j),K);  % FFT
%             XR(:,j) = fft(xr((i-1)*Ns+(1:N),j),K);  % FFT
        end
        %Rvv computation
        for k = 1:K
            corrvar = XR(k,:).' * conj(XR(k,:));
            glo_Rvv_s(:,:,k) =(1-alpha)*glo_Rvv_s(:,:,k) + alpha*corrvar/ trace(corrvar);            
        end  
    end
    
        % filter coefficent
        for k = 1:K/2+1
            for q = 1:Nnode
                steer = avec_a_20nodes_s(q)*exp(-sqrt(-1)*2*pi*(k-1)/K*F_msc*avec_tao_20nodes_s(q));
                Ny(q,k) = 1/glo_Rvv_s(q,q,k)*conj(steer)*X_win(k,i,q);
                Dy(q,k) = abs(steer)*abs(steer)*1/glo_Rvv_s(q,q,k);               
            end
            % distributed consensus stages
            for dc = 1:100
                 Ny(:,k) = Ws*Ny(:,k);
                 Dy(:,k) = Ws*Dy(:,k);
            end
            %
             Xout(k,i)  = Ny(1,k)/Dy(1,k); % after distributed consensus stages, all nodes have the same or similar output, thus, here the output of the 1st channel is showed to evaluate the speech enhancement perfermance
        end

        for k = 2:K/2
             Xout(k+K/2,i) = conj(Xout(K/2+2-k,i));
        end
   
end
% Xout = Xout';
%% output
xtmp = real(ifft(Xout))';
xout = overlapadd(xtmp,win,Ns);
audiowrite('xout.wav',xout/max(max(abs(xout))),F_msc);

